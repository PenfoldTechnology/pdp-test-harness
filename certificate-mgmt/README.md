# C&A Stub Certificate Manager

To support mTLS, certificates are required for both the server and clients, ensuring mutual trust.

The server uses a self-signed certificate stored in its **key store** and accepts any requests signed by a client 
with a certificate issued by a trusted Certificate Authority (CA) added to the server's **trust store**.

The [ca-manager.sh](./cert-manager.sh) CLI assists with :

- Creating a root CA
- Creating a subordinate CA signed by the root CA
- Create the trust-store to be configured in the server

The [cert-manager.sh](./cert-manager.sh) CLI assists with setting up the application, including the following tasks:

- Generating server certificates signed by the subordinate CA and using them for the stub
- Generating client certificates signed by the subordinate CA and using them for testing
- Creating a _Crypto-Pack_ based on the generated files
- Testing the generated _Crypto-Pack_ by making a valid `cURL` request using the client certificate and trusting the CA 
  that signed the server certificate

It defaults to use `localhost` as server name and `client` for the client, using those values for the CN subjects.

## Using the [`cert-manager`](./cert-manager.sh) script

The repository contains files for run the application used the commited files. Use these commands to create a 
personalized setup

### Create a new Root CA

It will create a new Root CA. If it exists, it will delete the previous version of the Root CA and the Subordinate CA

```shell
ROOT_CA_PATH=ca/rootCA
./ca-manager.sh createRootCa $ROOT_CA_PATH
```

### Create a new Subordinate CA

It will create a new Subordinate CA. And configure it as trusted. 

```shell
ROOT_CA_PATH=$ROOT_CA_PATH
SUBORDINATE_CA_PATH=$SUBORDINATE_CA_PATH
./ca-manager.sh createSubordinateCa $ROOT_CA_PATH $SUBORDINATE_CA_PATH
```

### Create server certificates

Using the Subordinate CA in the system, it will create the server certificate and use it for configuring the HTTPS
traffic between server and clients.

If not CN is provided, it defaults to `localhost`

```shell
SUBORDINATE_CA_PATH=$SUBORDINATE_CA_PATH
SERVER_CN=casstubserver
./cert-manager.sh createServerCerts $SUBORDINATE_CA_PATH $SERVER_CN
```

### Create client certificates

It will create a certificated, signed by the subordinate CA for the client. It will be trusted by the server

If not domain name is provided, it defaults to `client`

```shell
SUBORDINATE_CA_PATH=$SUBORDINATE_CA_PATH
CLIENT_CN=casstubclient
 ./cert-manager.sh createClientCerts $SUBORDINATE_CA_PATH $CLIENT_CN
```

## Generate server configuration files
```shell
SUBORDINATE_CA_PATH=$SUBORDINATE_CA_PATH
TRUST_STORE_PATH=mtls-server-config
SERVER_FILES_PATH="server"
KEY_STORE_PATH=mtls-server-config
./ca-manager.sh createTrustStore $SUBORDINATE_CA_PATH $TRUST_STORE_PATH
./cert-manager.sh createServerKeyStore $SERVER_FILES_PATH $KEY_STORE_PATH 
```

### Crypto pack

#### Create Crypto Pack 

It creates a crypto pack with the needed for setting up the _system under test_ in the route [example-crypto-pack](../crypto-pack-for-system-testing) 

```shell
ROOT_CA_PEM=$ROOT_CA_PATH/certs/rootCA.pem
SUBORDINATE_PEM=$SUBORDINATE_CA_PATH/certs/subordinateCA.pem
CLIENT_FILES_BASE_PATH="client/client"
CRYPTO_PACK_OUTPUT_PATH=./crypto-pack
./cert-manager.sh createCryptoPack $ROOT_CA_PEM $SUBORDINATE_PEM $CLIENT_FILES_BASE_PATH $CRYPTO_PACK_OUTPUT_PATH
```

#### Test Crypto Pack

It uses the files generated by the command above to make a cURL request.

```shell
CRYPTO_PACK_OUTPUT_PATH=$CRYPTO_PACK_OUTPUT_PATH
PORT=8443
DOMAIN_NAME=$SERVER_CN
./cert-manager.sh testCryptoPack $CRYPTO_PACK_OUTPUT_PATH $DOMAIN_NAME $PORT
```

It's equivalent to
```shell
CRYPTO_PACK_OUTPUT_PATH=$CRYPTO_PACK_OUTPUT_PATH
DOMAIN_NAME=$SERVER_CN
PORT=8443
curl \
  --cacert $CRYPTO_PACK_OUTPUT_PATH/certificateChain \
  --cert-type PEM \
  --cert $CRYPTO_PACK_OUTPUT_PATH/certificate \
  --key $CRYPTO_PACK_OUTPUT_PATH/certPrivateKey \
  --header "X-Request-ID: AE46BBEB-F4B2-40BA-8763-8B091E84CE3B" \
  --verbose \
  https://$DOMAIN_NAME:$PORT/jwk_uri
```
